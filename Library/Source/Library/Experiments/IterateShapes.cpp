#include "IterateShapes.h"

#include <iostream>
#include <TopoDS_Compound.hxx>
#include <TopoDS_Shape.hxx>
#include <BRep_Builder.hxx>
#include <BRepPrimAPI_MakeSphere.hxx>
#include <BRepPrimAPI_MakeCylinder.hxx>
#include <TopoDS_Iterator.hxx>
#include <string>

//sample generated by gemini ai

// Funktion, um den Typ eines TopoDS_Shape als String zurückzugeben (für die Ausgabe)
std::string GetShapeType(const TopoDS_Shape& shape)
{
    switch (shape.ShapeType())
    {
        case TopAbs_COMPOUND:
            return "Compound";
        case TopAbs_COMPSOLID:
            return "CompSolid";
        case TopAbs_SOLID:
            return "Solid";
        case TopAbs_SHELL:
            return "Shell";
        case TopAbs_FACE:
            return "Face";
        case TopAbs_WIRE:
            return "Wire";
        case TopAbs_EDGE:
            return "Edge";
        case TopAbs_VERTEX:
            return "Vertex";
        case TopAbs_SHAPE:
            return "Shape (Generic)";
        default:
            return "Unknown Shape Type";
    }
}

IterateShapes::IterateShapes()
{
    // 1. Erstelle ein TopoDS_Compound
    TopoDS_Compound aCompound;
    BRep_Builder    builder;
    builder.MakeCompound(aCompound);

    // 2. Erstelle einige Shapes
    TopoDS_Shape sphere   = BRepPrimAPI_MakeSphere(gp_Pnt(0, 0, 0), 5.0).Shape();
    TopoDS_Shape cylinder = BRepPrimAPI_MakeCylinder(gp_Ax2(gp_Pnt(10, 0, 0), gp_Dir(0, 0, 1)), 3.0, 10.0).Shape();

    // 3. Füge die Shapes dem Compound hinzu
    builder.Add(aCompound, sphere);
    builder.Add(aCompound, cylinder);

    // 4. Verwende TopoDS_Iterator, um über die direkten Shapes zu iterieren
    TopoDS_Iterator iterator(aCompound);
    int             shapeCount = 0;
    for (; iterator.More(); iterator.Next())
    {
        TopoDS_Shape currentShape = iterator.Value();

        shapeCount++;
        std::cout << "Shape " << shapeCount << ": Typ = " << GetShapeType(currentShape) << std::endl;
    }

    std::cout << "\nAnzahl der Shapes im Compound (via Iterator): " << shapeCount << std::endl;
}